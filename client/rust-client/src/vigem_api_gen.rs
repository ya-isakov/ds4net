#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::unreadable_literal)]
/* automatically generated by rust-bindgen */

pub type PVOID = *mut ::std::os::raw::c_void;
pub type HANDLE = PVOID;
pub type BYTE = ::std::os::raw::c_uchar;
pub type SHORT = ::std::os::raw::c_short;
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VIGEM_CLIENT {
    pub hBusDevice: HANDLE,
}
#[test]
fn bindgen_test_layout_VIGEM_CLIENT() {
    assert_eq!(
        ::std::mem::size_of::<VIGEM_CLIENT>(),
        8usize,
        concat!("Size of: ", stringify!(VIGEM_CLIENT))
    );
    assert_eq!(
        ::std::mem::align_of::<VIGEM_CLIENT>(),
        8usize,
        concat!("Alignment of ", stringify!(VIGEM_CLIENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_CLIENT>())).hBusDevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_CLIENT),
            "::",
            stringify!(hBusDevice)
        )
    );
}
pub type PVIGEM_CLIENT = *mut VIGEM_CLIENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VIGEM_TARGET_STATE {
    VIGEM_TARGET_NEW = 0,
    VIGEM_TARGET_INITIALIZED = 1,
    VIGEM_TARGET_CONNECTED = 2,
    VIGEM_TARGET_DISCONNECTED = 3,
}
pub type PVIGEM_TARGET_STATE = *mut VIGEM_TARGET_STATE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VIGEM_TARGET_TYPE {
    Xbox360Wired = 0,
    XboxOneWired = 1,
    DualShock4Wired = 2,
}
pub type PVIGEM_TARGET_TYPE = *mut VIGEM_TARGET_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VIGEM_TARGET {
    pub Size: ULONG,
    pub SerialNo: ULONG,
    pub State: VIGEM_TARGET_STATE,
    pub VendorId: USHORT,
    pub ProductId: USHORT,
    pub Type: VIGEM_TARGET_TYPE,
    pub Notification: DWORD_PTR,
}
#[test]
fn bindgen_test_layout_VIGEM_TARGET() {
    assert_eq!(
        ::std::mem::size_of::<VIGEM_TARGET>(),
        40usize,
        concat!("Size of: ", stringify!(VIGEM_TARGET))
    );
    assert_eq!(
        ::std::mem::align_of::<VIGEM_TARGET>(),
        8usize,
        concat!("Alignment of ", stringify!(VIGEM_TARGET))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).SerialNo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(SerialNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).State as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).VendorId as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(VendorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).ProductId as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).Type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VIGEM_TARGET>())).Notification as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VIGEM_TARGET),
            "::",
            stringify!(Notification)
        )
    );
}
pub type PVIGEM_TARGET = *mut VIGEM_TARGET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VIGEM_ERROR {
    VIGEM_ERROR_NONE = 536870912,
    VIGEM_ERROR_BUS_NOT_FOUND = 3758096385,
    VIGEM_ERROR_NO_FREE_SLOT = 3758096386,
    VIGEM_ERROR_INVALID_TARGET = 3758096387,
    VIGEM_ERROR_REMOVAL_FAILED = 3758096388,
    VIGEM_ERROR_ALREADY_CONNECTED = 3758096389,
    VIGEM_ERROR_TARGET_UNINITIALIZED = 3758096390,
    VIGEM_ERROR_TARGET_NOT_PLUGGED_IN = 3758096391,
    VIGEM_ERROR_BUS_VERSION_MISMATCH = 3758096392,
    VIGEM_ERROR_BUS_ACCESS_FAILED = 3758096393,
    VIGEM_ERROR_CALLBACK_ALREADY_REGISTERED = 3758096400,
    VIGEM_ERROR_CALLBACK_NOT_FOUND = 3758096401,
    VIGEM_ERROR_BUS_ALREADY_CONNECTED = 3758096402,
    VIGEM_ERROR_BUS_INVALID_HANDLE = 3758096403,
    VIGEM_ERROR_XUSB_USERINDEX_OUT_OF_RANGE = 3758096404,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XUSB_BUTTON {
    XUSB_GAMEPAD_DPAD_UP = 1,
    XUSB_GAMEPAD_DPAD_DOWN = 2,
    XUSB_GAMEPAD_DPAD_LEFT = 4,
    XUSB_GAMEPAD_DPAD_RIGHT = 8,
    XUSB_GAMEPAD_START = 16,
    XUSB_GAMEPAD_BACK = 32,
    XUSB_GAMEPAD_LEFT_THUMB = 64,
    XUSB_GAMEPAD_RIGHT_THUMB = 128,
    XUSB_GAMEPAD_LEFT_SHOULDER = 256,
    XUSB_GAMEPAD_RIGHT_SHOULDER = 512,
    XUSB_GAMEPAD_GUIDE = 1024,
    XUSB_GAMEPAD_A = 4096,
    XUSB_GAMEPAD_B = 8192,
    XUSB_GAMEPAD_X = 16384,
    XUSB_GAMEPAD_Y = 32768,
}
pub type PXUSB_BUTTON = *mut XUSB_BUTTON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XUSB_REPORT {
    pub wButtons: USHORT,
    pub bLeftTrigger: BYTE,
    pub bRightTrigger: BYTE,
    pub sThumbLX: SHORT,
    pub sThumbLY: SHORT,
    pub sThumbRX: SHORT,
    pub sThumbRY: SHORT,
}
#[test]
fn bindgen_test_layout_XUSB_REPORT() {
    assert_eq!(
        ::std::mem::size_of::<XUSB_REPORT>(),
        12usize,
        concat!("Size of: ", stringify!(XUSB_REPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<XUSB_REPORT>(),
        2usize,
        concat!("Alignment of ", stringify!(XUSB_REPORT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).wButtons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(wButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).bLeftTrigger as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(bLeftTrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).bRightTrigger as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(bRightTrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).sThumbLX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(sThumbLX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).sThumbLY as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(sThumbLY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).sThumbRX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(sThumbRX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUSB_REPORT>())).sThumbRY as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XUSB_REPORT),
            "::",
            stringify!(sThumbRY)
        )
    );
}
pub type PXUSB_REPORT = *mut XUSB_REPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DS4_LIGHTBAR_COLOR {
    pub Red: UCHAR,
    pub Green: UCHAR,
    pub Blue: UCHAR,
}
#[test]
fn bindgen_test_layout_DS4_LIGHTBAR_COLOR() {
    assert_eq!(
        ::std::mem::size_of::<DS4_LIGHTBAR_COLOR>(),
        3usize,
        concat!("Size of: ", stringify!(DS4_LIGHTBAR_COLOR))
    );
    assert_eq!(
        ::std::mem::align_of::<DS4_LIGHTBAR_COLOR>(),
        1usize,
        concat!("Alignment of ", stringify!(DS4_LIGHTBAR_COLOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_LIGHTBAR_COLOR>())).Red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_LIGHTBAR_COLOR),
            "::",
            stringify!(Red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_LIGHTBAR_COLOR>())).Green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_LIGHTBAR_COLOR),
            "::",
            stringify!(Green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_LIGHTBAR_COLOR>())).Blue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_LIGHTBAR_COLOR),
            "::",
            stringify!(Blue)
        )
    );
}
pub type PDS4_LIGHTBAR_COLOR = *mut DS4_LIGHTBAR_COLOR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DS4_BUTTONS {
    DS4_BUTTON_THUMB_RIGHT = 32768,
    DS4_BUTTON_THUMB_LEFT = 16384,
    DS4_BUTTON_OPTIONS = 8192,
    DS4_BUTTON_SHARE = 4096,
    DS4_BUTTON_TRIGGER_RIGHT = 2048,
    DS4_BUTTON_TRIGGER_LEFT = 1024,
    DS4_BUTTON_SHOULDER_RIGHT = 512,
    DS4_BUTTON_SHOULDER_LEFT = 256,
    DS4_BUTTON_TRIANGLE = 128,
    DS4_BUTTON_CIRCLE = 64,
    DS4_BUTTON_CROSS = 32,
    DS4_BUTTON_SQUARE = 16,
}
pub type PDS4_BUTTONS = *mut DS4_BUTTONS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DS4_SPECIAL_BUTTONS {
    DS4_SPECIAL_BUTTON_PS = 1,
    DS4_SPECIAL_BUTTON_TOUCHPAD = 2,
}
pub type PDS4_SPECIAL_BUTTONS = *mut DS4_SPECIAL_BUTTONS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DS4_DPAD_DIRECTIONS {
    DS4_BUTTON_DPAD_NONE = 8,
    DS4_BUTTON_DPAD_NORTHWEST = 7,
    DS4_BUTTON_DPAD_WEST = 6,
    DS4_BUTTON_DPAD_SOUTHWEST = 5,
    DS4_BUTTON_DPAD_SOUTH = 4,
    DS4_BUTTON_DPAD_SOUTHEAST = 3,
    DS4_BUTTON_DPAD_EAST = 2,
    DS4_BUTTON_DPAD_NORTHEAST = 1,
    DS4_BUTTON_DPAD_NORTH = 0,
}
pub type PDS4_DPAD_DIRECTIONS = *mut DS4_DPAD_DIRECTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DS4_REPORT {
    pub bThumbLX: BYTE,
    pub bThumbLY: BYTE,
    pub bThumbRX: BYTE,
    pub bThumbRY: BYTE,
    pub wButtons: USHORT,
    pub bSpecial: BYTE,
    pub bTriggerL: BYTE,
    pub bTriggerR: BYTE,
}
#[test]
fn bindgen_test_layout_DS4_REPORT() {
    assert_eq!(
        ::std::mem::size_of::<DS4_REPORT>(),
        10usize,
        concat!("Size of: ", stringify!(DS4_REPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<DS4_REPORT>(),
        2usize,
        concat!("Alignment of ", stringify!(DS4_REPORT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bThumbLX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bThumbLX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bThumbLY as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bThumbLY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bThumbRX as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bThumbRX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bThumbRY as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bThumbRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).wButtons as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(wButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bSpecial as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bSpecial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bTriggerL as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bTriggerL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DS4_REPORT>())).bTriggerR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DS4_REPORT),
            "::",
            stringify!(bTriggerR)
        )
    );
}
pub type PDS4_REPORT = *mut DS4_REPORT;
pub type EVT_VIGEM_TARGET_ADD_RESULT = ::std::option::Option<
    unsafe extern "C" fn(Client: PVIGEM_CLIENT, Target: PVIGEM_TARGET, Result: VIGEM_ERROR),
>;
pub type PFN_VIGEM_TARGET_ADD_RESULT = EVT_VIGEM_TARGET_ADD_RESULT;
pub type EVT_VIGEM_X360_NOTIFICATION = ::std::option::Option<
    unsafe extern "C" fn(
        Client: PVIGEM_CLIENT,
        Target: PVIGEM_TARGET,
        LargeMotor: UCHAR,
        SmallMotor: UCHAR,
        LedNumber: UCHAR,
    ),
>;
pub type PFN_VIGEM_X360_NOTIFICATION = EVT_VIGEM_X360_NOTIFICATION;
pub type EVT_VIGEM_DS4_NOTIFICATION = ::std::option::Option<
    unsafe extern "C" fn(
        Client: PVIGEM_CLIENT,
        Target: PVIGEM_TARGET,
        LargeMotor: UCHAR,
        SmallMotor: UCHAR,
        LightbarColor: DS4_LIGHTBAR_COLOR,
    ),
>;
pub type PFN_VIGEM_DS4_NOTIFICATION = EVT_VIGEM_DS4_NOTIFICATION;
extern "C" {
    pub fn vigem_alloc() -> PVIGEM_CLIENT;
}
extern "C" {
    pub fn vigem_free(vigem: PVIGEM_CLIENT);
}
extern "C" {
    pub fn vigem_connect(vigem: PVIGEM_CLIENT) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_disconnect(vigem: PVIGEM_CLIENT);
}
extern "C" {
    pub fn vigem_target_x360_alloc() -> PVIGEM_TARGET;
}
extern "C" {
    pub fn vigem_target_ds4_alloc() -> PVIGEM_TARGET;
}
extern "C" {
    pub fn vigem_target_free(target: PVIGEM_TARGET);
}
extern "C" {
    pub fn vigem_target_add(vigem: PVIGEM_CLIENT, target: PVIGEM_TARGET) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_target_remove(vigem: PVIGEM_CLIENT, target: PVIGEM_TARGET) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_target_x360_register_notification(
        vigem: PVIGEM_CLIENT,
        target: PVIGEM_TARGET,
        notification: PFN_VIGEM_X360_NOTIFICATION,
    ) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_target_ds4_register_notification(
        vigem: PVIGEM_CLIENT,
        target: PVIGEM_TARGET,
        notification: PFN_VIGEM_DS4_NOTIFICATION,
    ) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_target_x360_unregister_notification(target: PVIGEM_TARGET);
}
extern "C" {
    pub fn vigem_target_ds4_unregister_notification(target: PVIGEM_TARGET);
}
extern "C" {
    pub fn vigem_target_x360_update(
        vigem: PVIGEM_CLIENT,
        target: PVIGEM_TARGET,
        report: XUSB_REPORT,
    ) -> VIGEM_ERROR;
}
extern "C" {
    pub fn vigem_target_ds4_update(
        vigem: PVIGEM_CLIENT,
        target: PVIGEM_TARGET,
        report: DS4_REPORT,
    ) -> VIGEM_ERROR;
}
